{% extends "base.html" %}

{% block title %}Dashboard - Lightning AI Studio{% endblock %}

{% block content %}
<div class="space-y-6">
    <!-- Header -->
    <div class="flex flex-col md:flex-row justify-between items-start md:items-center">
        <div>
            <h1 class="text-3xl md:text-4xl font-bold mb-2">
                <i class="fas fa-bolt text-yellow-400 mr-3"></i>
                Lightning AI Studio Dashboard
            </h1>
            <p class="text-gray-400 text-lg">
                Enhanced control panel with scheduling and automation
            </p>
        </div>
        
        <!-- Quick Actions -->
        <div class="flex flex-wrap gap-3 mt-4 md:mt-0">
            <button id="quickStartBtn" class="btn-primary px-4 py-2 rounded-lg font-semibold flex items-center">
                <i class="fas fa-play mr-2"></i>Quick Start
            </button>
            <button id="quickStopBtn" class="bg-red-600 hover:bg-red-700 px-4 py-2 rounded-lg font-semibold flex items-center">
                <i class="fas fa-stop mr-2"></i>Quick Stop
            </button>
            <button id="restartBtn" class="bg-yellow-600 hover:bg-yellow-700 px-4 py-2 rounded-lg font-semibold flex items-center">
                <i class="fas fa-redo mr-2"></i>Restart
            </button>
        </div>
    </div>

    <!-- Studio Control Panel -->
    <div class="card rounded-lg shadow-lg p-6">
        <div class="flex flex-col md:flex-row items-start md:items-center justify-between mb-6">
            <div>
                <h2 class="text-xl font-semibold mb-2">Studio Control</h2>
                <p class="text-gray-400">Manage your Lightning AI studio instance</p>
            </div>
            
            <!-- Machine Type Selector -->
            <div class="mt-4 md:mt-0">
                <label class="block text-sm font-medium text-gray-300 mb-2">Machine Type</label>
                <select id="machineTypeSelect" class="bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white">
                    <option value="CPU">CPU</option>
                    <option value="GPU">GPU</option>
                    <option value="GPU_FAST">GPU Fast</option>
                </select>
            </div>
        </div>
        
        <!-- Control Buttons -->
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
            <button id="startBtn" class="bg-green-600 hover:bg-green-700 px-6 py-3 rounded-lg font-semibold transition-all transform hover:scale-105 flex items-center justify-center">
                <i class="fas fa-play mr-2"></i>Start Studio
            </button>
            <button id="stopBtn" class="bg-red-600 hover:bg-red-700 px-6 py-3 rounded-lg font-semibold transition-all transform hover:scale-105 flex items-center justify-center">
                <i class="fas fa-stop mr-2"></i>Stop Studio
            </button>
            <button id="restartStudioBtn" class="bg-yellow-600 hover:bg-yellow-700 px-6 py-3 rounded-lg font-semibold transition-all transform hover:scale-105 flex items-center justify-center">
                <i class="fas fa-redo mr-2"></i>Restart Studio
            </button>
        </div>
    </div>

    <!-- Status and Activity -->
    <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
        <!-- Current Status -->
        <div class="card rounded-lg shadow-lg p-6">
            <h3 class="text-lg font-semibold mb-4">Current Status</h3>
            <div id="currentStatus" class="space-y-3">
                <div class="flex items-center justify-between">
                    <span class="text-gray-400">Status:</span>
                    <span id="statusValue" class="font-semibold">Loading...</span>
                </div>
                <div class="flex items-center justify-between">
                    <span class="text-gray-400">Uptime:</span>
                    <span id="uptimeValue" class="text-sm">--</span>
                </div>
                <div class="flex items-center justify-between">
                    <span class="text-gray-400">Last Updated:</span>
                    <span id="lastUpdated" class="text-sm">--</span>
                </div>
            </div>
        </div>
        
        <!-- Quick Stats -->
        <div class="card rounded-lg shadow-lg p-6">
            <h3 class="text-lg font-semibold mb-4">Quick Stats</h3>
            <div id="quickStats" class="space-y-3">
                <div class="flex items-center justify-between">
                    <span class="text-gray-400">Active Schedules:</span>
                    <span id="activeSchedules" class="font-semibold">--</span>
                </div>
                <div class="flex items-center justify-between">
                    <span class="text-gray-400">Recent Executions:</span>
                    <span id="recentExecutions" class="font-semibold">--</span>
                </div>
            </div>
        </div>
        
        <!-- Quick Links -->
        <div class="card rounded-lg shadow-lg p-6">
            <h3 class="text-lg font-semibold mb-4">Quick Links</h3>
            <div class="space-y-2">
                <a href="/scheduler" class="block w-full text-left px-3 py-2 bg-gray-700 hover:bg-gray-600 rounded-lg transition-colors">
                    <i class="fas fa-clock mr-2"></i>Schedule Management
                </a>
                <a href="/files" class="block w-full text-left px-3 py-2 bg-gray-700 hover:bg-gray-600 rounded-lg transition-colors">
                    <i class="fas fa-folder mr-2"></i>File Manager
                </a>
                <a href="/terminal" class="block w-full text-left px-3 py-2 bg-gray-700 hover:bg-gray-600 rounded-lg transition-colors">
                    <i class="fas fa-terminal mr-2"></i>Python Terminal
                </a>
            </div>
        </div>
    </div>

    <!-- Activity Timeline -->
    <div class="card rounded-lg shadow-lg p-6">
        <div class="flex flex-col md:flex-row justify-between items-start md:items-center mb-6">
            <div>
                <h2 class="text-xl font-semibold mb-2">Studio Activity Timeline</h2>
                <p class="text-gray-400">Real-time activity monitoring</p>
            </div>
            
            <!-- Time Range Selector -->
            <div class="flex space-x-1 bg-gray-700 p-1 rounded-lg mt-4 md:mt-0">
                <button id="1h-btn" class="time-range-btn px-3 py-1 rounded-md text-sm font-medium active" onclick="setTimeRange('1h')">1 Hour</button>
                <button id="24h-btn" class="time-range-btn px-3 py-1 rounded-md text-sm font-medium" onclick="setTimeRange('24h')">24 Hours</button>
            </div>
        </div>
        
        <div class="h-64">
            <canvas id="uptimeChart"></canvas>
        </div>
    </div>
</div>

<!-- Modal -->
<div id="modal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center hidden z-50">
    <div class="bg-gray-800 p-8 rounded-lg shadow-2xl text-center max-w-sm w-full mx-4">
        <h2 id="modalTitle" class="text-2xl font-bold mb-4"></h2>
        <p id="modalMessage" class="text-lg mb-6"></p>
        <div id="modalSpinner" class="animate-spin rounded-full h-16 w-16 border-b-4 border-blue-400 mx-auto hidden"></div>
        <div id="modalActions" class="space-x-2"></div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
let currentRange = '1h';
let uptimeChart;
const chartCanvas = document.getElementById('uptimeChart');

// Status mapping
const STATUS_MAP = {
    running: { color: 'rgba(52, 211, 153, 0.8)', label: 'Running' },
    stopped: { color: 'rgba(239, 68, 68, 0.8)', label: 'Stopped' },
    starting: { color: 'rgba(251, 191, 36, 0.8)', label: 'Starting' },
    stopping: { color: 'rgba(249, 115, 22, 0.8)', label: 'Stopping' },
    restarting: { color: 'rgba(251, 146, 60, 0.8)', label: 'Restarting' },
    error: { color: 'rgba(190, 24, 93, 0.8)', label: 'Error' },
    unknown: { color: 'rgba(107, 114, 128, 0.8)', label: 'Unknown' }
};

// Modal functions
const modal = document.getElementById('modal');
const modalTitle = document.getElementById('modalTitle');
const modalMessage = document.getElementById('modalMessage');
const modalSpinner = document.getElementById('modalSpinner');
const modalActions = document.getElementById('modalActions');
let progressInterval;

function showModal(title, message, actions = [], showSpinner = false) {
    modalTitle.textContent = title;
    modalMessage.textContent = message;
    modalSpinner.style.display = showSpinner ? 'block' : 'none';
    modalActions.innerHTML = '';
    
    actions.forEach(action => {
        const button = document.createElement('button');
        button.textContent = action.text;
        button.className = action.class;
        button.onclick = action.onclick;
        modalActions.appendChild(button);
    });
    
    modal.classList.remove('hidden');
}

function closeModal() {
    modal.classList.add('hidden');
    clearInterval(progressInterval);
}

// Enhanced Chart functions with activity lanes
function getActivityType(log) {
    const type = log.event_type;
    if (type === 'status_check') return 'Heartbeat';
    if (type.includes('start')) return 'Start';
    if (type.includes('stop')) return 'Stop';
    return 'Events'; // This includes errors and other events
}

function getStatusFromLog(log) {
    const type = log.event_type;
    if (type.includes('running') || type === 'start' || type === 'post_start' || 
        (type === 'status_check' && log.metadata && log.metadata.status === 'running')) return 'running';
    if (type.includes('stopped') || type.includes('stop') || 
        (type === 'status_check' && log.metadata && log.metadata.status === 'stopped')) return 'stopped';
    if (type.includes('starting') || type.includes('start_begin') || 
        (type === 'status_check' && log.metadata && log.metadata.status === 'starting')) return 'starting';
    if (type.includes('stopping') || 
        (type === 'status_check' && log.metadata && log.metadata.status === 'stopping')) return 'stopping';
    if (type.includes('restarting') || 
        (type === 'status_check' && log.metadata && log.metadata.status === 'restarting')) return 'restarting';
    if (type.includes('error') || 
        (type === 'status_check' && log.metadata && log.metadata.status === 'error')) return 'error';
    return 'unknown';
}

function formatDuration(ms) {
    if (ms < 1000) return `${Math.round(ms)}ms`;
    const s = ms / 1000;
    if (s < 60) return `${s.toFixed(1)}s`;
    const m = s / 60;
    if (m < 60) return `${m.toFixed(1)}m`;
    const h = m / 60;
    return `${h.toFixed(1)}h`;
}

function createChart(logs, range) {
    const datasets = [];
    const timeConfig = {
        '1h': { unit: 'minute', min: new Date(new Date().getTime() - 60 * 60 * 1000) },
        '24h': { unit: 'hour', min: new Date(new Date().getTime() - 24 * 60 * 60 * 1000) }
    };
    
    const activityLanes = ['Start', 'Stop', 'Events', 'Heartbeat'];
    const now = new Date();
    // Add 10% padding after current time
    const paddedMax = new Date(now.getTime() + (now.getTime() - timeConfig[range].min.getTime()) * 0.1);
    
    if (logs.length > 0) {
        // Sort logs chronologically (oldest first for processing)
        const sortedLogs = [...logs].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
        
        // Create heartbeat line dataset
        let currentStatus = 'unknown';
        let lastHeartbeatTime = null;
        
        // Process heartbeat data
        for (let i = 0; i < sortedLogs.length; i++) {
            const log = sortedLogs[i];
            const logTime = new Date(log.timestamp);
            
            if (log.event_type === 'status_check' && log.metadata && log.metadata.status) {
                const newStatus = log.metadata.status;
                const color = newStatus === 'running' ? 'rgba(52, 211, 153, 1)' : 'rgba(239, 68, 68, 1)';
                
                // If status changed or this is the first heartbeat, create a line segment
                if (lastHeartbeatTime && currentStatus === newStatus) {
                    // Continue the same status line
                    datasets.push({
                        type: 'line',
                        label: `Status: ${newStatus}`,
                        data: [
                            { x: lastHeartbeatTime, y: 'Heartbeat' },
                            { x: logTime, y: 'Heartbeat' }
                        ],
                        borderColor: color,
                        backgroundColor: color,
                        borderWidth: 3,
                        pointRadius: 2,
                        pointHoverRadius: 4,
                        tension: 0,
                        showLine: true
                    });
                }
                
                currentStatus = newStatus;
                lastHeartbeatTime = logTime;
            }
        }
        
        // Extend heartbeat line to current time
        if (lastHeartbeatTime && currentStatus !== 'unknown') {
            const color = currentStatus === 'running' ? 'rgba(52, 211, 153, 1)' : 'rgba(239, 68, 68, 1)';
            datasets.push({
                type: 'line',
                label: `Status: ${currentStatus}`,
                data: [
                    { x: lastHeartbeatTime, y: 'Heartbeat' },
                    { x: now, y: 'Heartbeat' }
                ],
                borderColor: color,
                backgroundColor: color,
                borderWidth: 3,
                pointRadius: 2,
                pointHoverRadius: 4,
                tension: 0,
                showLine: true
            });
        }
        
        // Process operation events
        for (const log of sortedLogs) {
            const activityType = getActivityType(log);
            const status = getStatusFromLog(log);
            
            // Skip heartbeat events as they're handled above
            if (activityType === 'Heartbeat') continue;
            
            const lane = activityType; // 'Start', 'Stop', or 'Events'
            const eventTime = new Date(log.timestamp);
            
            if (log.event_type.includes('success') || log.event_type.includes('error')) {
                // Operation completion events - show as duration bars if we have timing data
                let duration = 5000; // Default 5 seconds
                let startTime = eventTime;
                
                if (log.metadata && log.metadata.duration_seconds) {
                    duration = log.metadata.duration_seconds * 1000;
                    if (log.metadata.start_time) {
                        startTime = new Date(log.metadata.start_time);
                    } else {
                        startTime = new Date(eventTime.getTime() - duration);
                    }
                }
                
                const color = STATUS_MAP[status]?.color || STATUS_MAP.unknown.color;
                
                datasets.push({
                    type: 'bar',
                    label: log.event_type,
                    data: [{
                        x: [startTime, eventTime],
                        y: lane
                    }],
                    backgroundColor: color,
                    borderColor: color,
                    borderWidth: 1,
                    barThickness: 15,
                    categoryPercentage: 0.8,
                    eventData: {
                        event_type: log.event_type,
                        duration: duration,
                        note: log.note,
                        timestamp: log.timestamp
                    }
                });
            } else if (!log.event_type.includes('begin')) {
                // Point events (not duration-based)
                const color = STATUS_MAP[status]?.color || STATUS_MAP.unknown.color;
                
                datasets.push({
                    type: 'scatter',
                    label: log.event_type,
                    data: [{
                        x: eventTime,
                        y: lane
                    }],
                    backgroundColor: color,
                    borderColor: color,
                    pointRadius: 5,
                    pointHoverRadius: 7,
                    eventData: {
                        event_type: log.event_type,
                        note: log.note,
                        timestamp: log.timestamp
                    }
                });
            }
        }
    }

    const config = {
        type: 'scatter', // Use scatter as base type for mixed chart
        data: { datasets },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
                intersect: false,
                mode: 'nearest'
            },
            plugins: {
                legend: { 
                    display: false // Hide legend to avoid clutter
                },
                tooltip: {
                    filter: function(tooltipItem) {
                        // Only show tooltips for actual data points, not lines
                        return tooltipItem.dataset.type !== 'line';
                    },
                    callbacks: {
                        title: (ctx) => {
                            const point = ctx[0];
                            if (point.dataset.type === 'bar' && Array.isArray(point.raw.x)) {
                                return `${new Date(point.raw.x[0]).toLocaleString()} - ${new Date(point.raw.x[1]).toLocaleString()}`;
                            }
                            return new Date(point.raw.x).toLocaleString();
                        },
                        label: (ctx) => {
                            const eventData = ctx.dataset.eventData;
                            if (eventData) {
                                let label = eventData.event_type;
                                if (eventData.duration) {
                                    label += ` (Duration: ${formatDuration(eventData.duration)})`;
                                }
                                if (eventData.note) {
                                    label += `\n${eventData.note}`;
                                }
                                return label;
                            }
                            return ctx.dataset.label;
                        }
                    }
                }
            },
            scales: {
                x: {
                    type: 'time',
                    time: { unit: timeConfig[range].unit },
                    min: timeConfig[range].min,
                    max: paddedMax,
                    grid: { color: 'rgba(255, 255, 255, 0.1)' },
                    ticks: { color: 'white' }
                },
                y: {
                    type: 'category',
                    labels: activityLanes,
                    grid: { display: false },
                    ticks: { color: 'white' }
                }
            }
        }
    };
    
    if (uptimeChart) uptimeChart.destroy();
    uptimeChart = new Chart(chartCanvas, config);
}

// Data fetching
async function fetchData(range) {
    try {
        const response = await fetch(`/api/logs?range=${range}`);
        const data = await response.json();
        createChart(data.logs, range);
        updateStatus(data.live_status);
    } catch (error) {
        console.error('Failed to fetch data:', error);
        showNotification('Failed to fetch data', 'error');
    }
}

function updateStatus(liveStatus) {
    const statusValue = document.getElementById('statusValue');
    const uptimeValue = document.getElementById('uptimeValue');
    const lastUpdated = document.getElementById('lastUpdated');
    
    // Get all buttons
    const startBtn = document.getElementById('startBtn');
    const quickStartBtn = document.getElementById('quickStartBtn');
    const stopBtn = document.getElementById('stopBtn');
    const quickStopBtn = document.getElementById('quickStopBtn');
    const restartBtn = document.getElementById('restartStudioBtn');
    const quickRestartBtn = document.getElementById('restartBtn');
    
    statusValue.textContent = liveStatus.status;
    lastUpdated.textContent = new Date().toLocaleString();
    
    // Update uptime
    if (liveStatus.status === 'running' && liveStatus.uptime) {
        uptimeValue.textContent = liveStatus.uptime;
        uptimeValue.className = 'text-sm text-green-400';
    } else if (liveStatus.status === 'running' && liveStatus.uptime_error) {
        uptimeValue.textContent = 'Error getting uptime';
        uptimeValue.className = 'text-sm text-yellow-400';
    } else {
        uptimeValue.textContent = '--';
        uptimeValue.className = 'text-sm text-gray-400';
    }
    
    // Update status class
    statusValue.className = 'font-semibold ';
    if (liveStatus.status === 'running') {
        statusValue.className += 'text-green-400';
    } else if (liveStatus.status === 'stopped') {
        statusValue.className += 'text-red-400';
    } else if (['starting', 'stopping', 'restarting'].includes(liveStatus.status)) {
        statusValue.className += 'text-yellow-400';
    } else {
        statusValue.className += 'text-gray-400';
    }
    
    // Update button states based on studio status (only if not in operation)
    if (!isOperationInProgress()) {
        updateButtonStates(liveStatus.status);
    }
}

function isOperationInProgress() {
    // Check if any operation is currently in progress
    return progressInterval !== null || operationState.type !== null;
}

function updateButtonStates(status) {
    const startBtn = document.getElementById('startBtn');
    const quickStartBtn = document.getElementById('quickStartBtn');
    const stopBtn = document.getElementById('stopBtn');
    const quickStopBtn = document.getElementById('quickStopBtn');
    const restartBtn = document.getElementById('restartStudioBtn');
    const quickRestartBtn = document.getElementById('restartBtn');
    
    // Reset all buttons first
    [startBtn, quickStartBtn, stopBtn, quickStopBtn, restartBtn, quickRestartBtn].forEach(btn => {
        btn.classList.remove('opacity-50', 'cursor-not-allowed');
        btn.disabled = false;
        btn.title = '';
    });
    
    if (status === 'running') {
        // Disable start buttons when running
        [startBtn, quickStartBtn].forEach(btn => {
            btn.disabled = true;
            btn.classList.add('opacity-50', 'cursor-not-allowed');
            btn.title = 'Studio is already running';
        });
    } else if (status === 'stopped') {
        // Disable stop and restart buttons when stopped
        [stopBtn, quickStopBtn, restartBtn, quickRestartBtn].forEach(btn => {
            btn.disabled = true;
            btn.classList.add('opacity-50', 'cursor-not-allowed');
        });
        stopBtn.title = 'Studio is already stopped';
        quickStopBtn.title = 'Studio is already stopped';
        restartBtn.title = 'Cannot restart when studio is stopped';
        quickRestartBtn.title = 'Cannot restart when studio is stopped';
    }
    // For starting/stopping/restarting states, keep all buttons enabled for user feedback
}

function setTimeRange(range) {
    currentRange = range;
    document.getElementById('1h-btn').classList.toggle('active', range === '1h');
    document.getElementById('24h-btn').classList.toggle('active', range === '24h');
    fetchData(range);
}

// Studio control functions
async function startStudio() {
    const machineType = document.getElementById('machineTypeSelect').value;
    const startBtn = document.getElementById('startBtn');
    const quickStartBtn = document.getElementById('quickStartBtn');
    
    // Disable buttons and show starting state
    startBtn.disabled = true;
    quickStartBtn.disabled = true;
    startBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>Starting...';
    quickStartBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>Starting...';
    
    try {
        const response = await fetch('/api/start', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ machine_type: machineType })
        });
        
        const data = await response.json();
        
        if (data.start_id) {
            // Save operation state
            saveOperationState('start', data.start_id);
            
            let seconds = 0;
            progressInterval = setInterval(() => {
                seconds++;
                startBtn.innerHTML = `<i class="fas fa-spinner fa-spin mr-2"></i>Starting (${seconds}s)`;
                quickStartBtn.innerHTML = `<i class="fas fa-spinner fa-spin mr-2"></i>Starting (${seconds}s)`;
                checkProgress(data.start_id);
            }, 1000);
        } else {
            // Reset buttons on error
            resetStartButtons();
            const actions = [{ text: 'Close', class: 'bg-blue-600 hover:bg-blue-700 px-6 py-2 rounded-lg font-semibold', onclick: closeModal }];
            showModal("❌ Error!", data.error || "An unknown error occurred.", actions);
        }
    } catch (error) {
        resetStartButtons();
        const actions = [{ text: 'Close', class: 'bg-blue-600 hover:bg-blue-700 px-6 py-2 rounded-lg font-semibold', onclick: closeModal }];
        showModal("❌ Error!", "Failed to start studio", actions);
    }
}

function resetStartButtons() {
    const startBtn = document.getElementById('startBtn');
    const quickStartBtn = document.getElementById('quickStartBtn');
    startBtn.disabled = false;
    quickStartBtn.disabled = false;
    startBtn.innerHTML = '<i class="fas fa-play mr-2"></i>Start Studio';
    quickStartBtn.innerHTML = '<i class="fas fa-play mr-2"></i>Quick Start';
    clearOperationState(); // Clear saved operation state
}

async function stopStudio() {
    const actions = [
        { text: 'Cancel', class: 'bg-gray-600 hover:bg-gray-700 px-6 py-2 rounded-lg font-semibold mr-4', onclick: closeModal },
        { text: 'Yes, Stop It', class: 'bg-red-600 hover:bg-red-700 px-6 py-2 rounded-lg font-semibold', onclick: async () => {
            closeModal();
            const stopBtn = document.getElementById('stopBtn');
            const quickStopBtn = document.getElementById('quickStopBtn');
            
            // Disable buttons and show stopping state with countdown
            stopBtn.disabled = true;
            quickStopBtn.disabled = true;
            
            // Save operation state
            saveOperationState('stop');
            
            let stopSeconds = 0;
            const stopInterval = setInterval(() => {
                stopSeconds++;
                stopBtn.innerHTML = `<i class="fas fa-spinner fa-spin mr-2"></i>Stopping (${stopSeconds}s)`;
                quickStopBtn.innerHTML = `<i class="fas fa-spinner fa-spin mr-2"></i>Stopping (${stopSeconds}s)`;
            }, 1000);
            
            try {
                const response = await fetch('/api/stop', { method: 'POST' });
                const data = await response.json();
                
                clearInterval(stopInterval);
                
                if(data.success) {
                    showModal("✅ Command Sent", "Stop command sent successfully.", [{ text: 'Close', class: 'bg-blue-600 hover:bg-blue-700 px-6 py-2 rounded-lg font-semibold', onclick: closeModal }]);
                } else {
                    showModal("❌ Error", `Failed to stop: ${data.error}`, [{ text: 'Close', class: 'bg-blue-600 hover:bg-blue-700 px-6 py-2 rounded-lg font-semibold', onclick: closeModal }]);
                }
                
                // Reset buttons after a delay
                setTimeout(() => {
                    stopBtn.disabled = false;
                    quickStopBtn.disabled = false;
                    stopBtn.innerHTML = '<i class="fas fa-stop mr-2"></i>Stop Studio';
                    quickStopBtn.innerHTML = '<i class="fas fa-stop mr-2"></i>Quick Stop';
                    clearOperationState(); // Clear saved operation state
                }, 3000);
                
                fetchData(currentRange);
            } catch (error) {
                clearInterval(stopInterval);
                showModal("❌ Error", "Failed to stop studio", [{ text: 'Close', class: 'bg-blue-600 hover:bg-blue-700 px-6 py-2 rounded-lg font-semibold', onclick: closeModal }]);
                // Reset buttons on error
                stopBtn.disabled = false;
                quickStopBtn.disabled = false;
                stopBtn.innerHTML = '<i class="fas fa-stop mr-2"></i>Stop Studio';
                quickStopBtn.innerHTML = '<i class="fas fa-stop mr-2"></i>Quick Stop';
                clearOperationState(); // Clear saved operation state
            }
        }}
    ];
    
    showModal("Confirm Stop", "Are you sure you want to stop the studio?", actions);
}

async function restartStudio() {
    const machineType = document.getElementById('machineTypeSelect').value;
    const restartBtn = document.getElementById('restartStudioBtn');
    const quickRestartBtn = document.getElementById('restartBtn');
    
    // Disable buttons and show restarting state with countdown
    restartBtn.disabled = true;
    quickRestartBtn.disabled = true;
    
    // Save operation state
    saveOperationState('restart');
    
    let restartSeconds = 0;
    const restartInterval = setInterval(() => {
        restartSeconds++;
        restartBtn.innerHTML = `<i class="fas fa-spinner fa-spin mr-2"></i>Restarting (${restartSeconds}s)`;
        quickRestartBtn.innerHTML = `<i class="fas fa-spinner fa-spin mr-2"></i>Restarting (${restartSeconds}s)`;
    }, 1000);
    
    try {
        const response = await fetch('/api/restart', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ machine_type: machineType })
        });
        
        const data = await response.json();
        clearInterval(restartInterval);
        
        const closeAction = [{ text: 'Close', class: 'bg-blue-600 hover:bg-blue-700 px-6 py-2 rounded-lg font-semibold', onclick: closeModal }];
        
        if(data.success) {
            showModal("✅ Command Sent", "Restart command sent successfully.", closeAction);
        } else {
            showModal("❌ Error", `Failed to restart: ${data.error}`, closeAction);
        }
        
        // Reset buttons after a delay
        setTimeout(() => {
            restartBtn.disabled = false;
            quickRestartBtn.disabled = false;
            restartBtn.innerHTML = '<i class="fas fa-redo mr-2"></i>Restart Studio';
            quickRestartBtn.innerHTML = '<i class="fas fa-redo mr-2"></i>Restart';
            clearOperationState(); // Clear saved operation state
        }, 3000);
        
        fetchData(currentRange);
    } catch (error) {
        clearInterval(restartInterval);
        const closeAction = [{ text: 'Close', class: 'bg-blue-600 hover:bg-blue-700 px-6 py-2 rounded-lg font-semibold', onclick: closeModal }];
        showModal("❌ Error", "Failed to restart studio", closeAction);
        
        // Reset buttons on error
        restartBtn.disabled = false;
        quickRestartBtn.disabled = false;
        restartBtn.innerHTML = '<i class="fas fa-redo mr-2"></i>Restart Studio';
        quickRestartBtn.innerHTML = '<i class="fas fa-redo mr-2"></i>Restart';
        clearOperationState(); // Clear saved operation state
    }
}

async function checkProgress(startId) {
    try {
        const response = await fetch(`/api/start/progress/${startId}`);
        const data = await response.json();
        
        if (data.status === 'completed') {
            clearInterval(progressInterval);
            progressInterval = null; // Reset progress interval
            resetStartButtons();
            
            const actions = [{ text: 'Close', class: 'bg-blue-600 hover:bg-blue-700 px-6 py-2 rounded-lg font-semibold', onclick: closeModal }];
            
            if (data.success) {
                showModal("✅ Success!", "Studio started successfully!", actions);
            } else {
                showModal("❌ Error!", `Failed to start: ${data.error}`, actions);
            }
            
            fetchData(currentRange);
        }
        // For 'starting' status, we just continue showing the countdown in the button
    } catch (error) {
        console.error('Error checking progress:', error);
        clearInterval(progressInterval);
        progressInterval = null; // Reset progress interval
        resetStartButtons();
    }
}

// Event listeners
document.getElementById('startBtn').addEventListener('click', startStudio);
document.getElementById('stopBtn').addEventListener('click', stopStudio);
document.getElementById('restartStudioBtn').addEventListener('click', restartStudio);
document.getElementById('quickStartBtn').addEventListener('click', startStudio);
document.getElementById('quickStopBtn').addEventListener('click', stopStudio);
document.getElementById('restartBtn').addEventListener('click', restartStudio);

// State persistence for operations
let operationState = {
    type: null, // 'start', 'stop', 'restart'
    startTime: null,
    startId: null
};

function saveOperationState(type, startId = null) {
    operationState = {
        type: type,
        startTime: Date.now(),
        startId: startId
    };
    localStorage.setItem('studioOperationState', JSON.stringify(operationState));
}

function loadOperationState() {
    const saved = localStorage.getItem('studioOperationState');
    if (saved) {
        operationState = JSON.parse(saved);
        // Check if operation is still valid (not older than 5 minutes)
        if (operationState.startTime && (Date.now() - operationState.startTime) < 300000) {
            restoreOperationUI();
        } else {
            clearOperationState();
        }
    }
}

function clearOperationState() {
    operationState = { type: null, startTime: null, startId: null };
    localStorage.removeItem('studioOperationState');
}

function restoreOperationUI() {
    if (!operationState.type) return;
    
    const elapsed = Math.floor((Date.now() - operationState.startTime) / 1000);
    
    if (operationState.type === 'start') {
        const startBtn = document.getElementById('startBtn');
        const quickStartBtn = document.getElementById('quickStartBtn');
        startBtn.disabled = true;
        quickStartBtn.disabled = true;
        startBtn.innerHTML = `<i class="fas fa-spinner fa-spin mr-2"></i>Starting (${elapsed}s)`;
        quickStartBtn.innerHTML = `<i class="fas fa-spinner fa-spin mr-2"></i>Starting (${elapsed}s)`;
        
        // Resume progress checking if we have a start ID
        if (operationState.startId) {
            let seconds = elapsed;
            progressInterval = setInterval(() => {
                seconds++;
                startBtn.innerHTML = `<i class="fas fa-spinner fa-spin mr-2"></i>Starting (${seconds}s)`;
                quickStartBtn.innerHTML = `<i class="fas fa-spinner fa-spin mr-2"></i>Starting (${seconds}s)`;
                checkProgress(operationState.startId);
            }, 1000);
        }
    } else if (operationState.type === 'stop') {
        const stopBtn = document.getElementById('stopBtn');
        const quickStopBtn = document.getElementById('quickStopBtn');
        stopBtn.disabled = true;
        quickStopBtn.disabled = true;
        stopBtn.innerHTML = `<i class="fas fa-spinner fa-spin mr-2"></i>Stopping (${elapsed}s)`;
        quickStopBtn.innerHTML = `<i class="fas fa-spinner fa-spin mr-2"></i>Stopping (${elapsed}s)`;
        
        // Continue counting for stop operation
        let seconds = elapsed;
        const stopInterval = setInterval(() => {
            seconds++;
            stopBtn.innerHTML = `<i class="fas fa-spinner fa-spin mr-2"></i>Stopping (${seconds}s)`;
            quickStopBtn.innerHTML = `<i class="fas fa-spinner fa-spin mr-2"></i>Stopping (${seconds}s)`;
            
            // Auto-clear after reasonable time (30 seconds)
            if (seconds > 30) {
                clearInterval(stopInterval);
                clearOperationState();
                stopBtn.disabled = false;
                quickStopBtn.disabled = false;
                stopBtn.innerHTML = '<i class="fas fa-stop mr-2"></i>Stop Studio';
                quickStopBtn.innerHTML = '<i class="fas fa-stop mr-2"></i>Quick Stop';
                fetchData(currentRange); // Refresh data
            }
        }, 1000);
    } else if (operationState.type === 'restart') {
        const restartBtn = document.getElementById('restartStudioBtn');
        const quickRestartBtn = document.getElementById('restartBtn');
        restartBtn.disabled = true;
        quickRestartBtn.disabled = true;
        restartBtn.innerHTML = `<i class="fas fa-spinner fa-spin mr-2"></i>Restarting (${elapsed}s)`;
        quickRestartBtn.innerHTML = `<i class="fas fa-spinner fa-spin mr-2"></i>Restarting (${elapsed}s)`;
        
        // Continue counting for restart operation
        let seconds = elapsed;
        const restartInterval = setInterval(() => {
            seconds++;
            restartBtn.innerHTML = `<i class="fas fa-spinner fa-spin mr-2"></i>Restarting (${seconds}s)`;
            quickRestartBtn.innerHTML = `<i class="fas fa-spinner fa-spin mr-2"></i>Restarting (${seconds}s)`;
            
            // Auto-clear after reasonable time (60 seconds)
            if (seconds > 60) {
                clearInterval(restartInterval);
                clearOperationState();
                restartBtn.disabled = false;
                quickRestartBtn.disabled = false;
                restartBtn.innerHTML = '<i class="fas fa-redo mr-2"></i>Restart Studio';
                quickRestartBtn.innerHTML = '<i class="fas fa-redo mr-2"></i>Restart';
                fetchData(currentRange); // Refresh data
            }
        }, 1000);
    }
}

// Initialize
loadOperationState(); // Load any ongoing operations
setTimeRange('1h');
setInterval(() => fetchData(currentRange), 300000);

// Fetch initial data immediately
fetchData('1h');

// Also fetch status more frequently for uptime updates (every 60 seconds)
setInterval(async () => {
    try {
        const response = await fetch('/api/status');
        const data = await response.json();
        updateStatus(data);
    } catch (error) {
        console.error('Failed to fetch status:', error);
    }
}, 60000);

// Load quick stats
async function loadQuickStats() {
    try {
        // Load schedules count
        const schedulesResponse = await fetch('/scheduler/list');
        const schedulesData = await schedulesResponse.json();
        const activeSchedules = schedulesData.schedules ? schedulesData.schedules.filter(s => s.enabled).length : 0;
        document.getElementById('activeSchedules').textContent = activeSchedules;
        
        // Load executions count
        const executionsResponse = await fetch('/files/execution-history?limit=10');
        const executionsData = await executionsResponse.json();
        const recentExecutions = executionsData.history ? executionsData.history.length : 0;
        document.getElementById('recentExecutions').textContent = recentExecutions;
    } catch (error) {
        console.error('Failed to load quick stats:', error);
    }
}

loadQuickStats();
</script>

<style>
.time-range-btn.active {
    background-color: #4f46e5;
    color: white;
}
</style>
{% endblock %}